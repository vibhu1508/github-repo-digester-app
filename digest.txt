
# File: hardhat.config.ts

require("@nomicfoundation/hardhat-ethers");
require("@nomicfoundation/hardhat-toolbox");
require("dotenv").config();

/** @type import('hardhat/config').HardhatUserConfig */
const config = {
  solidity: "0.8.20",
  networks: {
    hardhat: {
      chainId: 1337,
    },
  },
  paths: {
    sources: "./src/contracts",
    tests: "./test",
    cache: "./cache",
    artifacts: "./artifacts",
  },
  typechain: {
    outDir: "typechain-types",
  },
};

module.exports = config;



# File: package.json

{
  "name": "privacy-preserving-id-system",
  "version": "1.0.0",
  "main": "src/web/index.tsx",
  "scripts": {
    "start": "webpack serve --mode development",
    "build": "webpack --mode production",
    "test": "jest",
    "compile:circuits": "npx mkdirp build && circom src/circuits/multiAttributeVerification.circom --r1cs --wasm --sym --prime bn128 -l node_modules/circomlib/circuits -o build",
    "setup:circuits": "cd build && snarkjs ptn bn128 12 pot12_0000.ptau && snarkjs ptc pot12_0000.ptau pot12_0001.ptau -e=\"some random text\"",
    "phase2:circuits": "cd build && snarkjs pt2 pot12_0001.ptau pot12_final.ptau && snarkjs g16s multiAttributeVerification.r1cs pot12_final.ptau circuit_0000.zkey",
    "contribute:key": "cd build && snarkjs zkc circuit_0000.zkey circuit_final.zkey -e=\"some random text\"",
    "export:key": "cd build && snarkjs zkev circuit_final.zkey verification_key.json"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "devDependencies": {
    "@nomicfoundation/hardhat-ethers": "^3.0.0",
    "@nomicfoundation/hardhat-toolbox": "^4.0.0",
    "@openzeppelin/contracts": "^5.0.1",
    "@types/chai": "^4.3.4",
    "@types/mocha": "^10.0.1",
    "@types/node": "^20.11.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "assert": "^2.1.0",
    "autoprefixer": "^10.4.20",
    "browserify-sign": "^4.2.3",
    "browserify-zlib": "^0.2.0",
    "buffer": "^6.0.3",
    "chai": "^4.3.7",
    "circomlib": "^2.0.5",
    "constants-browserify": "^1.0.0",
    "crypto-browserify": "^3.12.1",
    "css-loader": "^6.8.1",
    "events": "^3.3.0",
    "hardhat": "^2.19.4",
    "html-webpack-plugin": "^5.6.0",
    "https-browserify": "^1.0.0",
    "jest": "^29.7.0",
    "mocha": "^10.2.0",
    "os-browserify": "^0.3.0",
    "path-browserify": "^1.0.1",
    "postcss": "^8.4.31",
    "postcss-loader": "^7.3.3",
    "prettier": "^3.1.1",
    "process": "^0.11.10",
    "querystring-es3": "^0.2.1",
    "snarkjs": "^0.7.2",
    "solhint": "^4.0.0",
    "stream-browserify": "^3.0.0",
    "stream-http": "^3.2.0",
    "style-loader": "^3.3.3",
    "ts-loader": "^9.5.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3",
    "url": "^0.11.4",
    "util": "^0.12.5",
    "vm-browserify": "^1.1.2",
    "webpack": "^5.89.0",
    "webpack-cli": "^5.1.4",
    "webpack-dev-server": "^4.15.1"
  },
  "dependencies": {
    "@headlessui/react": "^1.7.17",
    "@radix-ui/react-alert-dialog": "^1.1.4",
    "@radix-ui/react-dialog": "^1.1.4",
    "@radix-ui/react-slot": "^1.1.1",
    "@web3-react/core": "^8.2.3",
    "@web3-react/injected-connector": "^6.0.7",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dotenv": "^16.0.3",
    "dotenv-expand": "^10.0.0",
    "ipfs-http-client": "^60.0.1",
    "kubo-rpc-client": "^5.0.2",
    "lucide-react": "^0.469.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tailwind-merge": "^2.6.0",
    "tailwindcss": "^3.4.17",
    "tailwindcss-animate": "^1.0.7",
    "web3": "^4.16.0"
  }
}



# File: postcss.config.js

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}



# File: README.md

# Privacy-Preserving Decentralized Identity Verification System

## Description

A prototype decentralized identity verification system that leverages zero-knowledge proofs to verify user attributes (age, income, residency) without revealing the actual data. The system enables users to demonstrate specific attributes while maintaining privacy of their sensitive information. Built with Ethereum smart contracts, ZK-SNARKs, and React.

### Why This Project?

Traditional identity verification systems often require users to expose sensitive personal information. This project enables privacy-preserving verification where users can prove they meet certain criteria without revealing their actual data. By using ZK-SNARKs technology, we can ensure that verification happens without compromising user privacy.

## Table of Contents

- [Features](#features)
- [Architecture](#architecture)
- [Prerequisites](#prerequisites)
- [Installation](#installation)
- [Usage](#usage)
- [Technical Details](#technical-details)
- [Testing](#testing)
- [Documentation](#documentation)

## Features

- 🔐 Zero-knowledge proofs for private attribute verification
- 🌐 Decentralized identity management with DID creation
- ⛓️ Ethereum smart contract integration for proof verification
- 🔍 Multi-attribute verification (age, income, residency)
- 📱 React-based user interface for proof generation and verification
- 🔒 MetaMask wallet integration
- 📂 Off-chain storage for verifiable credentials
- ✅ Comprehensive test suite for system validation

## Architecture

```mermaid
graph TB
    subgraph Frontend
        UI[React UI] --> Web3Context
        Web3Context --> DIDManager
    end

    subgraph ZK-Proofs
        DIDManager --> ProofGenerator
        ProofGenerator --> CircuitWASM[Circuit WASM]
    end

    subgraph Blockchain
        Web3Context --> SmartContract[Identity Verifier Contract]
        ProofGenerator --> SmartContract
    end

    subgraph Storage
        DIDManager --> IPFS
    end
```

## Prerequisites

- Node.js >= 16.0.0
- MetaMask wallet
- Git
- Local blockchain environment (Hardhat)
- Circom (for ZK-SNARK circuit compilation)

## Installation

1. Clone the repository:

```bash
git clone https://github.com/yourusername/privacy-preserving-id-system.git
cd privacy-preserving-id-system
```

2. Install dependencies:

```bash
npm install
```

3. Set up environment variables:

```bash
cp .env.example .env
```

Edit .env with your configuration:

```
REACT_APP_CONTRACT_ADDRESS=your_contract_address
REACT_APP_IPFS_NODE=http://localhost:5001
REACT_APP_PROVIDER_URL=http://localhost:8545
```

4. Compile the circuits:

```bash
npm run compile:circuits
npm run setup:circuits
npm run phase2:circuits
npm run contribute:key
npm run export:key
```

5. Deploy the smart contract:

```bash
npx hardhat run scripts/deploy.ts --network localhost
```

## Usage

1. Start the development server:

```bash
npm start
```

2. Connect your MetaMask wallet to the application

3. Create a DID with your credentials:

```typescript
const credentials = {
  age: 25,
  income: 50000,
  residency: "NY",
};
```

4. Generate and submit proofs for verification:

```typescript
const conditions = {
  ageThreshold: 18,
  incomeThreshold: 30000,
  expectedResidency: "NY",
};
```

## Technical Details

### Core Dependencies

- React: ^18.2.0
- Ethers.js: ^6.0.0
- Hardhat: ^2.19.4
- Circom: ^2.1.6
- SnarkJS: ^0.7.2
- Web3.js: ^4.16.0
- TailwindCSS: ^3.4.17

### Smart Contracts

- Solidity: ^0.8.20
- OpenZeppelin Contracts: ^5.0.1

### Development Tools

- TypeScript: ^5.3.3
- Webpack: ^5.89.0
- PostCSS: ^8.4.31

## Testing

The system includes comprehensive test cases demonstrating:

- DID creation and management
- Proof generation for single and multiple attributes
- Smart contract verification
- End-to-end system functionality

To run tests:

```bash
npm test
```

## Documentation

Detailed documentation is available covering:

- System architecture and components
- ZK-SNARK proof generation process
- Smart contract functionality
- API documentation
- Setup and deployment instructions

## Security Considerations

- All proofs are verified on-chain
- Private data never leaves the user's device
- Zero-knowledge proofs ensure data privacy
- Smart contract audited for security vulnerabilities
- Regular security updates and patches

## Contributing

Contributions are welcome! Please read our contributing guidelines before submitting pull requests.

## License

This project is licensed under the MIT License - see the LICENSE file for details.



# File: tailwind.config.js

/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: ["./src/**/*.{ts,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [require("tailwindcss-animate")],
};



# File: tsconfig.hardhat.json

{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "allowJs": true
  },
  "include": ["hardhat.config.ts", "scripts", "test"],
  "files": ["hardhat.config.ts"]
}



# File: tsconfig.json

{
  "compilerOptions": {
    "target": "esnext",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": false,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "typeRoots": ["./node_modules/@types", "./src/types"]
  },
  "include": ["src", "src/types", "src/types/ethereum.d.ts"]
}



# File: webpack.config.js

const path = require("path");
const HtmlWebpackPlugin = require("html-webpack-plugin");
const webpack = require("webpack");
const dotenv = require("dotenv");

// Load environment variables
const env = dotenv.config().parsed || {};

module.exports = {
  entry: "./src/web/index.tsx",
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "bundle.js",
  },
  module: {
    rules: [
      {
        test: /\.(ts|tsx)$/,
        use: "ts-loader",
        exclude: /node_modules/,
      },
      {
        test: /\.css$/,
        use: ["style-loader", "css-loader", "postcss-loader"],
      },
    ],
  },
  resolve: {
    extensions: [".tsx", ".ts", ".js", ".jsx"],
    alias: {
      "@": path.resolve(__dirname, "src"),
      process: "process/browser.js",
    },
    fallback: {
      crypto: require.resolve("crypto-browserify"),
      stream: require.resolve("stream-browserify"),
      assert: require.resolve("assert/"),
      http: require.resolve("stream-http"),
      https: require.resolve("https-browserify"),
      os: require.resolve("os-browserify/browser"),
      url: require.resolve("url/"),
      buffer: require.resolve("buffer/"),
      process: require.resolve("process/browser"),
      path: require.resolve("path-browserify"),
      fs: false,
      vm: require.resolve("vm-browserify"),
      querystring: require.resolve("querystring-es3"),
      zlib: require.resolve("browserify-zlib"),
      util: require.resolve("util/"),
      tls: false,
      net: false,
    },
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: "./public/index.html",
    }),
    new webpack.ProvidePlugin({
      process: "process/browser.js",
      Buffer: ["buffer", "Buffer"],
    }),
    new webpack.DefinePlugin({
      "process.env": JSON.stringify(env),
    }),
    // Fix for ESM modules
    new webpack.NormalModuleReplacementPlugin(/node:/, (resource) => {
      resource.request = resource.request.replace(/^node:/, "");
    }),
  ],
  devServer: {
    static: {
      directory: path.join(__dirname, "public"),
    },
    compress: true,
    port: 3000,
    hot: true,
  },
};



# File: deployments\localhost.json

{
  "verifierAddress": "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512",
  "deployer": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
  "network": "localhost",
  "timestamp": "2025-01-07T03:24:01.428Z",
  "verificationKey": {
    "alpha1": [
      "18198833613768359238708285212923191863030541811016354442521484258853569046499",
      "14791043891343121342093537371294390665494084832093987375186581109246864734638"
    ],
    "beta2": [
      [
        "14907685278720769185874540198485686411545101293875704976257129328466399803942",
        "17407040243260285384855731418037305038765635485521859207028330500639200231864"
      ],
      [
        "18083091036147176255670916437439426482993007172288867115698143828739917733102",
        "9498296812876007667242637820372634674605413362052407968205820526876621944396"
      ]
    ],
    "gamma2": [
      [
        "10857046999023057135944570762232829481370756359578518086990519993285655852781",
        "11559732032986387107991004021392285783925812861821192530917403151452391805634"
      ],
      [
        "8495653923123431417604973247489272438418190587263600148770280649306958101930",
        "4082367875863433681332203403145435568316851327593401208105741076214120093531"
      ]
    ],
    "delta2": [
      [
        "21807827614272719885111506576605345433271888153636046528500247429615745314138",
        "7203536431838888267069727061200524213909071772707228094944923811214718844451"
      ],
      [
        "6386684453129361065203692430522536258048760018685863134855899094095493588767",
        "21143620412697430468272832646934680894323211609210148988482374949824274557122"
      ]
    ],
    "IC": [
      [
        "14677241675718478246542868325940010456180052215480221137995744821129419739770",
        "7499291154276006594170876784646260629524886246650404470531905203063751289867"
      ],
      [
        "7155841851602955118747884652956937076421405621582130735630125771684170406218",
        "15173125659666880917302408622294808361991227871858225399241560865321690357805"
      ],
      [
        "11057940029306604738780295832011369216610054432744573730963671220974868574697",
        "20218189943387181118093509053196196397396644230609897569923865395787671626108"
      ],
      [
        "1085280042064189469459869735632459009290390875558304394794555489838549779734",
        "5961646000744847685276845101050003082294075342529875802049673337593633349181"
      ]
    ]
  }
}


# File: public\index.html

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Identity Verification System</title>
  </head>
  <body>
    <div id="root"></div>
    <script src="../dist/bundle.js"></script>
  </body>
</html>



# File: scripts\deploy.ts

const { ethers, network } = require("hardhat");
const fs = require("fs");
const path = require("path");
const snarkjs = require("snarkjs");

async function main() {
  const [deployer] = await ethers.getSigners();
  console.log("Deploying contracts with account:", deployer.address);

  try {
    // Load verification key from the circuit compilation
    const vKeyPath = path.join(__dirname, "../build/verification_key.json");
    const vKey = JSON.parse(fs.readFileSync(vKeyPath, "utf-8"));

    // Format verification key for the contract
    const alpha1 = [
      BigInt(vKey.vk_alpha_1[0]).toString(),
      BigInt(vKey.vk_alpha_1[1]).toString(),
    ];

    const beta2 = [
      [
        BigInt(vKey.vk_beta_2[0][0]).toString(),
        BigInt(vKey.vk_beta_2[0][1]).toString(),
      ],
      [
        BigInt(vKey.vk_beta_2[1][0]).toString(),
        BigInt(vKey.vk_beta_2[1][1]).toString(),
      ],
    ];

    const gamma2 = [
      [
        BigInt(vKey.vk_gamma_2[0][0]).toString(),
        BigInt(vKey.vk_gamma_2[0][1]).toString(),
      ],
      [
        BigInt(vKey.vk_gamma_2[1][0]).toString(),
        BigInt(vKey.vk_gamma_2[1][1]).toString(),
      ],
    ];

    const delta2 = [
      [
        BigInt(vKey.vk_delta_2[0][0]).toString(),
        BigInt(vKey.vk_delta_2[0][1]).toString(),
      ],
      [
        BigInt(vKey.vk_delta_2[1][0]).toString(),
        BigInt(vKey.vk_delta_2[1][1]).toString(),
      ],
    ];

    const IC = vKey.IC.map((point: any) => [
      BigInt(point[0]).toString(),
      BigInt(point[1]).toString(),
    ]);

    // Deploy IdentityVerifier
    const IdentityVerifier =
      await ethers.getContractFactory("IdentityVerifier");
    const verifier = await IdentityVerifier.deploy(
      alpha1,
      beta2,
      gamma2,
      delta2,
      IC
    );

    // Wait for deployment to complete
    await verifier.waitForDeployment();
    const verifierAddress = await verifier.getAddress();

    console.log("IdentityVerifier deployed to:", verifierAddress);

    // Save deployment info
    const deploymentInfo = {
      verifierAddress,
      deployer: deployer.address,
      network: network.name,
      timestamp: new Date().toISOString(),
      verificationKey: { alpha1, beta2, gamma2, delta2, IC },
    };

    const deploymentsDir = path.join(__dirname, "../deployments");
    if (!fs.existsSync(deploymentsDir)) {
      fs.mkdirSync(deploymentsDir);
    }

    fs.writeFileSync(
      path.join(deploymentsDir, `${network.name}.json`),
      JSON.stringify(deploymentInfo, null, 2)
    );

    console.log(
      "Deployment info saved to:",
      `deployments/${network.name}.json`
    );
  } catch (error) {
    console.error("Deployment failed:", error);
    throw error;
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });



# File: src\config.ts

// src/config.ts
export const config = {
  CONTRACT_ADDRESS: process.env.REACT_APP_CONTRACT_ADDRESS || "",
  IPFS_NODE: process.env.REACT_APP_IPFS_NODE || "http://localhost:5001",
  PROVIDER_URL: process.env.REACT_APP_PROVIDER_URL || "http://localhost:8545",
  isDevelopment: process.env.NODE_ENV === "development",
};

// Function to validate config
export const validateConfig = () => {
  const requiredVars = ["CONTRACT_ADDRESS", "PROVIDER_URL"];
  const missingVars = requiredVars.filter(
    (varName) => !config[varName as keyof typeof config]
  );

  if (missingVars.length > 0) {
    throw new Error(
      `Missing required environment variables: ${missingVars.join(", ")}`
    );
  }
};



# File: src\polyfills.ts

import { Buffer } from "buffer";
import process from "process";

window.Buffer = Buffer;
window.process = process;



# File: src\circuits\proofGenerator.ts

import { groth16 } from "snarkjs";
import { ethers } from "ethers";
import path from "path";

interface AttributeProof {
  proof: any;
  publicSignals: any;
}

export interface ProofInput {
  age?: number;
  income?: number;
  residency?: string;
  ageThreshold?: number;
  incomeThreshold?: number;
  residencyHash?: string;
  secret: string;
}

export const generateProof = async (input: ProofInput) => {
  const circuitPath = path.join(__dirname, "../build/circuit.wasm");
  const zkeyPath = path.join(__dirname, "../build/circuit_final.zkey");

  const { proof, publicSignals } = await groth16.fullProve(
    input,
    circuitPath,
    zkeyPath
  );

  return {
    proof: {
      a: proof.pi_a.slice(0, 2),
      b: [proof.pi_b[0].slice(0, 2), proof.pi_b[1].slice(0, 2)],
      c: proof.pi_c.slice(0, 2),
    },
    publicSignals,
  };
};

export const verifyProof = async (proof: any, publicSignals: any) => {
  const vkeyPath = path.join(__dirname, "../build/verification_key.json");
  return await groth16.verify(vkeyPath, publicSignals, proof);
};

export class ProofGenerator {
  async generateMultiAttributeProof(
    credentials: any,
    conditions: any
  ): Promise<AttributeProof> {
    try {
      const input = {
        age: credentials.age,
        ageThreshold: conditions.ageThreshold || 0,
        income: credentials.income,
        incomeThreshold: conditions.incomeThreshold || 0,
        residencyHash: this.hashResidency(credentials.residency),
        expectedResidencyHash: this.hashResidency(
          conditions.expectedResidency || ""
        ),
      };

      return await groth16.fullProve(
        input,
        "/circuits/multiAttributeVerification.wasm",
        "/circuits/multiAttributeVerification.zkey"
      );
    } catch (error) {
      console.error("Error generating multi-attribute proof:", error);
      throw error;
    }
  }

  private hashResidency(residency: string): string {
    return ethers.keccak256(ethers.toUtf8Bytes(residency));
  }
}



# File: src\did\manager.ts

// src/did/manager.ts
import { ethers } from "ethers";
import { build0x } from "../utils/crypto";
import { DID } from "../types/did";

export interface Credential {
  age: number;
  income: number;
  residency: string;
  [key: string]: number | string;
}

export class DIDManager {
  private dids: Map<string, DID>;

  constructor() {
    this.dids = new Map();
    this.loadStoredDIDs();
  }

  async createDID(credentials: Credential): Promise<DID> {
    const randomBytes = ethers.randomBytes(32);
    const id = build0x(randomBytes);

    const did: DID = {
      id,
      credentials,
      created: Date.now(),
      updated: Date.now(),
      secret: ethers.keccak256(ethers.randomBytes(32)),
    };

    this.dids.set(id, did);
    await this.storeDID(did);

    return did;
  }

  private async storeDID(did: DID): Promise<void> {
    try {
      // Store in localStorage for browser environment
      const dids = JSON.parse(localStorage.getItem("dids") || "{}");
      dids[did.id] = did;
      localStorage.setItem("dids", JSON.stringify(dids));
    } catch (error) {
      console.error("Error storing DID:", error);
      throw error;
    }
  }

  private loadStoredDIDs(): void {
    try {
      const dids = JSON.parse(localStorage.getItem("dids") || "{}");
      Object.values(dids).forEach((did: any) => {
        this.dids.set(did.id, did);
      });
    } catch (error) {
      console.error("Error loading DIDs:", error);
    }
  }

  async getDID(id: string): Promise<DID | null> {
    return this.dids.get(id) || null;
  }
}



# File: src\services\verificationService.ts

import { Web3Service } from "../utils/web3";
import {
  generateProof,
  verifyProof,
  ProofInput,
} from "../circuits/proofGenerator";
import { DIDManager } from "../did/manager";
import { StorageManager } from "../storage/StorageManager";
import { ethers } from "ethers";
import { DID } from "../types/did";

interface VerificationConditions {
  ageThreshold?: number;
  incomeThreshold?: number;
  expectedResidency?: string;
}

export interface VerificationResult {
  success: boolean;
  proofId?: string;
  attributes: {
    age?: boolean;
    income?: boolean;
    residency?: boolean;
  };
}

export class VerificationService {
  private web3Service: Web3Service;
  private didManager: DIDManager;
  private storageManager: StorageManager;

  constructor(providerUrl: string, contractAddress: string, contractABI: any) {
    this.web3Service = new Web3Service(providerUrl);
    this.didManager = new DIDManager();
    this.storageManager = new StorageManager();
    this.initialize(contractAddress, contractABI);
  }

  private async initialize(
    contractAddress: string,
    contractABI: any
  ): Promise<void> {
    await this.web3Service.initialize(contractAddress, contractABI);
  }

  async verifyIdentityAttribute(
    didId: string,
    attributeName: string,
    condition: any
  ): Promise<boolean> {
    try {
      const did = await this.didManager.getDID(didId);
      if (!did) {
        throw new Error("DID not found");
      }

      const proof = await generateProof({
        [attributeName]: did.credentials[attributeName],
        ageThreshold: condition.threshold,
        secret: did.secret,
      });

      return await this.web3Service.verifyProof(
        proof.proof,
        proof.publicSignals
      );
    } catch (error) {
      console.error("Identity verification failed:", error);
      throw new Error("Verification process failed");
    }
  }

  async verifyMultipleAttributes(
    didId: string,
    conditions: VerificationConditions
  ): Promise<VerificationResult> {
    try {
      const did = await this.didManager.getDID(didId);
      if (!did) throw new Error("DID not found");

      const proof = await generateProof({
        age: Number(did.credentials.age),
        income: Number(did.credentials.income),
        residency: did.credentials.residency,
        ageThreshold: conditions.ageThreshold,
        incomeThreshold: conditions.incomeThreshold,
        residencyHash: conditions.expectedResidency,
        secret: did.secret,
      });

      const verificationSuccess = await this.web3Service.verifyProof(
        proof.proof,
        proof.publicSignals
      );

      const result: VerificationResult = {
        success: verificationSuccess,
        proofId: ethers.keccak256(ethers.toUtf8Bytes(JSON.stringify(proof))),
        attributes: {
          age:
            conditions.ageThreshold && typeof did.credentials.age === "number"
              ? did.credentials.age >= conditions.ageThreshold
              : undefined,
          income:
            conditions.incomeThreshold &&
            typeof did.credentials.income === "number"
              ? did.credentials.income >= conditions.incomeThreshold
              : undefined,
          residency:
            conditions.expectedResidency &&
            typeof did.credentials.residency === "string"
              ? did.credentials.residency === conditions.expectedResidency
              : undefined,
        },
      };

      if (verificationSuccess) {
        await this.storeVerificationResult(didId, result);
      }

      return result;
    } catch (error) {
      console.error("Multiple attribute verification failed:", error);
      throw new Error("Multi-attribute verification failed");
    }
  }

  private async storeVerificationResult(
    didId: string,
    result: VerificationResult
  ): Promise<void> {
    try {
      const verificationRecord = {
        didId,
        timestamp: Date.now(),
        result,
      };
      await this.storageManager.storeVerificationResult(verificationRecord);
    } catch (error) {
      console.error("Failed to store verification result:", error);
    }
  }

  async revokeVerification(didId: string, proofId: string): Promise<boolean> {
    try {
      return await this.web3Service.revokeVerification(didId, proofId);
    } catch (error) {
      console.error("Failed to revoke verification:", error);
      throw new Error("Verification revocation failed");
    }
  }
}



# File: src\storage\StorageManager.ts

import { create, IPFS } from "ipfs-http-client";
import type { IPFSHTTPClient } from "ipfs-http-client/types";
import { encrypt, decrypt } from "../utils/crypto";
import { DID } from "../types/did";
import { Credential } from "../did/manager";
import { VerificationResult } from "../services/verificationService";

interface VerificationRecord {
  didId: string;
  timestamp: number;
  result: VerificationResult;
}

export class StorageManager {
  private ipfs: IPFS; // Changed to IPFS
  private encryptionKey: string;

  constructor(ipfsNode: string = "http://localhost:5001") {
    this.ipfs = create({ url: ipfsNode }); // create returns an IPFS instance
    this.encryptionKey = process.env.ENCRYPTION_KEY || "default-key";
  }

  async store(did: DID): Promise<string> {
    // Encrypt sensitive data
    const encryptedCredentials = encrypt(
      JSON.stringify(did.credentials),
      this.encryptionKey
    );

    const didDocument = {
      ...did,
      credentials: encryptedCredentials,
    };

    // Store on IPFS
    const result = await this.ipfs.add(JSON.stringify(didDocument));
    return result.cid.toString();
  }

  async retrieve(cid: string): Promise<DID> {
    const chunks = [];
    for await (const chunk of this.ipfs.cat(cid)) {
      chunks.push(chunk);
    }

    const didDocument = JSON.parse(Buffer.concat(chunks).toString());

    // Decrypt credentials
    const decryptedCredentials = JSON.parse(
      decrypt(didDocument.credentials, this.encryptionKey)
    );

    return {
      ...didDocument,
      credentials: decryptedCredentials,
    };
  }

  async storeVerificationResult(record: VerificationRecord): Promise<string> {
    const result = await this.ipfs.add(JSON.stringify(record));
    return result.cid.toString();
  }
}



# File: src\types\circomlibjs.d.ts

declare module "circomlibjs" {
  export function buildPoseidon(): Promise<any>;
}



# File: src\types\did.ts

export interface DID {
  id: string;
  credentials: {
    age: number;
    income: number;
    residency: string;
    [key: string]: number | string;
  };
  created: number;
  updated: number;
  secret: string;
}



# File: src\types\ethereum.d.ts

import { Web3Service } from "../utils/web3";
import { EthereumProvider } from "./ethereum";

export interface EthereumProvider {
  isMetaMask?: boolean;
  selectedAddress?: string;
  isConnected?: () => boolean;
  request: (args: { method: string; params?: any[] }) => Promise<any>;
  on: (eventName: string, handler: (...args: any[]) => void) => void;
  removeListener: (
    eventName: string,
    handler: (...args: any[]) => void
  ) => void;
  removeAllListeners: (eventName: string) => void;
  autoRefreshOnNetworkChange?: boolean;
}

export interface Web3ContextState {
  web3Service: Web3Service | null;
  isConnected: boolean;
  account: string | null;
  connect: () => Promise<void>;
  disconnect: () => void;
  verifyProof: (proof: any, publicSignals: any) => Promise<boolean>;
  checkVerificationStatus: (address: string) => Promise<boolean>;
  error: string | null;
}

declare global {
  interface Window {
    ethereum?: EthereumProvider;
  }
}



# File: src\types\global.d.ts

import { EthereumProvider } from "./ethereum";

declare global {
  interface Window {
    ethereum?: EthereumProvider;
  }
}



# File: src\types\ipfs-http-client.d.ts

declare module "ipfs-http-client" {
  export interface IPFS {
    add(data: string): Promise<{ cid: { toString(): string } }>;
    cat(path: string): AsyncIterable<Uint8Array>;
  }

  export function create(options: { url: string }): IPFS;
  export default { create };
}



# File: src\types\snarkjs.d.ts

declare module "snarkjs" {
  export namespace groth16 {
    export function fullProve(
      input: any,
      wasmFile: string,
      zkeyFile: string
    ): Promise<{
      proof: any;
      publicSignals: any;
    }>;
    export function verify(
      vKey: any,
      publicSignals: any,
      proof: any
    ): Promise<boolean>;
  }
}



# File: src\types\window.d.ts

// src/types/window.d.ts
export {};

declare global {
  interface Window {
    ethereum?: {
      isMetaMask?: boolean;
      selectedAddress?: string;
      isConnected?: () => boolean;
      request: (args: { method: string; params?: any[] }) => Promise<any>;
      on: (eventName: string, handler: (...args: any[]) => void) => void;
      removeListener: (
        eventName: string,
        handler: (...args: any[]) => void
      ) => void;
      removeAllListeners: (eventName: string) => void;
      autoRefreshOnNetworkChange?: boolean;
    };
  }
}



# File: src\utils\crypto.ts

import { ethers } from "ethers";
import { Buffer } from "buffer";
import * as crypto from "crypto";

export function build0x(input: Buffer | string | Uint8Array): string {
  if (Buffer.isBuffer(input)) {
    return "0x" + input.toString("hex");
  }
  if (input instanceof Uint8Array) {
    return "0x" + Buffer.from(input).toString("hex");
  }
  if (typeof input === "string") {
    return input.startsWith("0x") ? input : "0x" + input;
  }
  throw new Error("Invalid input type");
}

export function generateSalt(): string {
  return build0x(ethers.randomBytes(32));
}

export function hashData(data: string): string {
  return ethers.keccak256(ethers.toUtf8Bytes(data));
}

export function isValidHex(hex: string): boolean {
  return ethers.isHexString(hex);
}

export function encrypt(data: string, key: string): string {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv("aes-256-gcm", Buffer.from(key), iv);

  let encrypted = cipher.update(data, "utf8", "hex");
  encrypted += cipher.final("hex");

  const authTag = cipher.getAuthTag();

  return JSON.stringify({
    iv: iv.toString("hex"),
    content: encrypted,
    authTag: authTag.toString("hex"),
  });
}

export function decrypt(encryptedData: string, key: string): string {
  const { iv, content, authTag } = JSON.parse(encryptedData);

  const decipher = crypto.createDecipheriv(
    "aes-256-gcm",
    Buffer.from(key),
    Buffer.from(iv, "hex")
  );

  decipher.setAuthTag(Buffer.from(authTag, "hex"));

  let decrypted = decipher.update(content, "hex", "utf8");
  decrypted += decipher.final("utf8");

  return decrypted;
}



# File: src\utils\web3.ts

import { ethers, Contract, Signer } from "ethers";
import { BrowserProvider, JsonRpcProvider } from "ethers";

export class Web3Service {
  private provider: BrowserProvider | JsonRpcProvider;
  private signer: Signer | null;
  private contract: Contract | null;

  constructor(providerUrl: string = "http://localhost:8545") {
    this.provider = new JsonRpcProvider(providerUrl);
    this.signer = null;
    this.contract = null;
  }

  async initialize(contractAddress: string, contractABI: any): Promise<void> {
    try {
      // Get signer if using browser provider (MetaMask)
      if (window.ethereum) {
        this.provider = new BrowserProvider(window.ethereum);
        this.signer = await this.provider.getSigner();
      }

      this.contract = new Contract(
        contractAddress,
        contractABI,
        this.signer || this.provider
      );
    } catch (error) {
      console.error("Failed to initialize Web3:", error);
      throw new Error("Web3 initialization failed");
    }
  }

  async verifyProof(proof: any, publicSignals: any): Promise<boolean> {
    if (!this.contract) {
      throw new Error("Contract not initialized");
    }

    try {
      const tx = await this.contract.verify(
        proof.a,
        proof.b,
        proof.c,
        publicSignals
      );
      const receipt = await tx.wait();

      // Check for VerificationResult event
      const event = receipt.events?.find(
        (e: any) => e.event === "VerificationResult"
      );

      return event?.args?.success || false;
    } catch (error) {
      console.error("Proof verification failed:", error);
      throw new Error("Proof verification failed");
    }
  }

  async checkVerificationStatus(address: string): Promise<boolean> {
    if (!this.contract) {
      throw new Error("Contract not initialized");
    }

    try {
      return await this.contract.verifiedUsers(address);
    } catch (error) {
      console.error("Failed to check verification status:", error);
      throw new Error("Status check failed");
    }
  }

  async revokeVerification(didId: string, proofId: string): Promise<boolean> {
    if (!this.contract) throw new Error("Contract not initialized");

    try {
      const tx = await this.contract.revokeVerification(didId, proofId);
      const receipt = await tx.wait();
      return true;
    } catch (error) {
      console.error("Revocation failed:", error);
      throw error;
    }
  }
}



# File: src\web\App.tsx

import React from "react";
import { createRoot } from "react-dom/client";
import { Web3Provider } from "./contexts/Web3Context";
import IdentityDashboard from "./components/IdentityDashboard";

function App() {
  return (
    <Web3Provider>
      <div className="app">
        <IdentityDashboard />
      </div>
    </Web3Provider>
  );
}

const container = document.getElementById("root");
if (!container) throw new Error("Root element not found");
const root = createRoot(container);
root.render(<App />);



# File: src\web\index.tsx

import React from "react";
import { createRoot } from "react-dom/client";
import { Web3Provider } from "./contexts/Web3Context";
import IdentityDashboard from "./components/IdentityDashboard";
import "./styles/globals.css";

const App = () => {
  return (
    <Web3Provider>
      <IdentityDashboard />
    </Web3Provider>
  );
};

const container = document.getElementById("root");
if (container) {
  const root = createRoot(container);
  root.render(
    <React.StrictMode>
      <App />
    </React.StrictMode>
  );
}



# File: src\web\components\Alert.tsx

// src/web/components/Alert.tsx
import React from "react";
import { Dialog, Transition } from "@headlessui/react";
import { Fragment } from "react";

interface AlertProps {
  children: React.ReactNode;
  className?: string;
}

interface AlertDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  children: React.ReactNode;
}

interface AlertDialogActionProps extends AlertProps {
  onClick?: () => void;
  disabled?: boolean;
}

// Basic Alert Components
export const Alert = ({ children, className = "" }: AlertProps) => {
  return (
    <div
      className={`p-4 rounded-md bg-yellow-50 border border-yellow-200 ${className}`}
    >
      {children}
    </div>
  );
};

export const AlertTitle = ({ children, className = "" }: AlertProps) => {
  return (
    <h4 className={`font-medium text-yellow-800 ${className}`}>{children}</h4>
  );
};

export const AlertDescription = ({ children, className = "" }: AlertProps) => {
  return (
    <p className={`mt-1 text-sm text-yellow-700 ${className}`}>{children}</p>
  );
};

// Alert Dialog Components
export const AlertDialog = ({
  open,
  onOpenChange,
  children,
}: AlertDialogProps) => {
  return (
    <Transition appear show={open} as={Fragment}>
      <Dialog
        as="div"
        className="relative z-50"
        onClose={() => onOpenChange?.(false)}
      >
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black bg-opacity-25" />
        </Transition.Child>
        {children}
      </Dialog>
    </Transition>
  );
};

export const AlertDialogContent = ({
  children,
  className = "",
}: AlertProps) => {
  return (
    <div className="fixed inset-0 overflow-y-auto">
      <div className="flex min-h-full items-center justify-center p-4 text-center">
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0 scale-95"
          enterTo="opacity-100 scale-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100 scale-100"
          leaveTo="opacity-0 scale-95"
        >
          <Dialog.Panel
            className={`w-full max-w-md transform overflow-hidden rounded-2xl bg-white p-6 text-left align-middle shadow-xl transition-all ${className}`}
          >
            {children}
          </Dialog.Panel>
        </Transition.Child>
      </div>
    </div>
  );
};

export const AlertDialogHeader = ({ children, className = "" }: AlertProps) => {
  return <div className={`mb-4 ${className}`}>{children}</div>;
};

export const AlertDialogTitle = ({ children, className = "" }: AlertProps) => {
  return (
    <Dialog.Title
      as="h3"
      className={`text-lg font-medium leading-6 text-gray-900 ${className}`}
    >
      {children}
    </Dialog.Title>
  );
};

export const AlertDialogDescription = ({
  children,
  className = "",
}: AlertProps) => {
  return (
    <p className={`mt-2 text-sm text-gray-500 ${className}`}>{children}</p>
  );
};

export const AlertDialogFooter = ({ children, className = "" }: AlertProps) => {
  return (
    <div className={`mt-4 flex justify-end space-x-2 ${className}`}>
      {children}
    </div>
  );
};

export const AlertDialogAction = ({
  children,
  onClick,
  className = "",
  disabled = false,
}: AlertDialogActionProps) => {
  return (
    <button
      type="button"
      className={`inline-flex justify-center rounded-md px-4 py-2 text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed ${className}`}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
};

export const AlertDialogCancel = ({
  children,
  onClick,
  className = "",
  disabled = false,
}: AlertDialogActionProps) => {
  return (
    <button
      type="button"
      className={`inline-flex justify-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus-visible:ring-2 focus-visible:ring-gray-500 focus-visible:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed ${className}`}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
};



# File: src\web\components\Button.tsx

// src/web/components/Button.tsx
import React from "react";

interface ButtonProps {
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
  className?: string;
  variant?: "default" | "outline" | "ghost" | "link";
  type?: "button" | "submit" | "reset";
}

export const Button = ({
  children,
  onClick,
  disabled = false,
  className = "",
  variant = "default",
  type = "button",
}: ButtonProps) => {
  const baseStyles =
    "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none";

  const variants = {
    default:
      "bg-indigo-600 text-white hover:bg-indigo-700 focus-visible:ring-indigo-500",
    outline:
      "border border-gray-300 bg-white hover:bg-gray-100 text-gray-700 focus-visible:ring-gray-500",
    ghost: "hover:bg-gray-100 text-gray-700 focus-visible:ring-gray-500",
    link: "text-indigo-600 hover:underline focus-visible:ring-indigo-500",
  };

  const variantStyles = variants[variant] || variants.default;

  return (
    <button
      type={type}
      onClick={onClick}
      disabled={disabled}
      className={`${baseStyles} ${variantStyles} ${className}`}
    >
      {children}
    </button>
  );
};



# File: src\web\components\Card.tsx

import React from "react";

interface CardProps {
  children: React.ReactNode;
  className?: string;
}

export const Card = ({ children, className = "" }: CardProps) => {
  return (
    <div
      className={`bg-white rounded-lg shadow-sm border border-gray-200 ${className}`}
    >
      {children}
    </div>
  );
};

export const CardHeader = ({ children, className = "" }: CardProps) => {
  return (
    <div className={`p-6 border-b border-gray-200 ${className}`}>
      {children}
    </div>
  );
};

export const CardContent = ({ children, className = "" }: CardProps) => {
  return <div className={`p-6 ${className}`}>{children}</div>;
};

export const CardTitle = ({ children, className = "" }: CardProps) => {
  return (
    <h3 className={`text-lg font-semibold text-gray-900 ${className}`}>
      {children}
    </h3>
  );
};

export const CardDescription = ({ children, className = "" }: CardProps) => {
  return (
    <p className={`mt-1 text-sm text-gray-500 ${className}`}>{children}</p>
  );
};



# File: src\web\components\IdentityDashboard.tsx

import React, { useState, useEffect } from "react";
import { Wallet, CircleUserRound, Shield, FileCheck } from "lucide-react";
import { Card, CardHeader, CardContent } from "./Card";
import { Button } from "./Button";
import { Alert } from "./Alert";
import { useWeb3 } from "../contexts/Web3Context";
import { DIDService } from "../services/DIDService";
import IdentityVerifierABI from "../../../artifacts/src/contracts/IdentityVerifier.sol/IdentityVerifier.json";

interface Credentials {
  age: string;
  residency: string;
  income: string;
}

function IdentityDashboard() {
  const { isConnected, account, connect, web3Service } = useWeb3();
  const [credentials, setCredentials] = useState<Credentials>({
    age: "",
    residency: "",
    income: "",
  });
  const [loading, setLoading] = useState(false);
  const [did, setDid] = useState<any>(null);
  const [error, setError] = useState<string | null>(null);
  const [didService, setDidService] = useState<DIDService | null>(null);

  useEffect(() => {
    if (web3Service) {
      const contractAddress = process.env.REACT_APP_CONTRACT_ADDRESS;
      if (contractAddress) {
        const service = new DIDService(
          "http://localhost:8545",
          contractAddress,
          IdentityVerifierABI
        );
        setDidService(service);
      }
    }
  }, [web3Service]);

  const handleCreateDID = async () => {
    if (!didService || !account) return;

    try {
      setLoading(true);
      setError(null);

      const result = await didService.createDID({
        age: parseInt(credentials.age),
        residency: credentials.residency,
        income: parseInt(credentials.income),
      });

      setDid(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to create DID");
    } finally {
      setLoading(false);
    }
  };

  const handleVerifyAttribute = async (attribute: string) => {
    if (!didService || !did) return;

    try {
      setLoading(true);
      setError(null);

      const condition = {
        value: credentials[attribute as keyof Credentials],
        threshold: attribute === "age" ? 18 : 0, // Example threshold
      };

      const proof = await didService.generateProof(
        did.id,
        attribute,
        condition
      );

      if (web3Service) {
        const isValid = await web3Service.verifyProof(
          proof.proof,
          proof.publicSignals
        );

        if (isValid) {
          // Handle successful verification
          console.log(`${attribute} verified successfully`);
        } else {
          setError("Verification failed");
        }
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Verification failed");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <nav className="bg-white shadow-sm">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between h-16 items-center">
            <div className="flex items-center">
              <Shield className="w-8 h-8 text-indigo-600" />
              <span className="ml-2 text-xl font-semibold">
                Identity Verifier
              </span>
            </div>
            <Button onClick={connect} disabled={isConnected || loading}>
              <Wallet className="w-4 h-4 mr-2" />
              {isConnected
                ? `Connected: ${account?.slice(0, 6)}...${account?.slice(-4)}`
                : "Connect Wallet"}
            </Button>
          </div>
        </div>
      </nav>

      <main className="max-w-7xl mx-auto py-6 px-4 sm:px-6 lg:px-8">
        {error && <Alert className="mb-6">{error}</Alert>}

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {/* DID Creation Card */}
          <Card>
            <CardHeader>
              <div className="flex items-center">
                <CircleUserRound className="w-5 h-5 mr-2" />
                <h3 className="text-lg font-semibold">Create Identity</h3>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Age
                  </label>
                  <input
                    type="number"
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                    value={credentials.age}
                    onChange={(e) =>
                      setCredentials({ ...credentials, age: e.target.value })
                    }
                    disabled={!isConnected || loading}
                  />
                </div>
                {/* Add other credential inputs */}
                <Button
                  onClick={handleCreateDID}
                  disabled={!isConnected || loading}
                >
                  {loading ? "Creating..." : "Create DID"}
                </Button>
              </div>
            </CardContent>
          </Card>

          {/* Verification Card */}
          <Card>
            <CardHeader>
              <div className="flex items-center">
                <FileCheck className="w-5 h-5 mr-2" />
                <h3 className="text-lg font-semibold">Verify Attributes</h3>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {did ? (
                  <>
                    <div className="p-4 bg-gray-50 rounded-lg">
                      <p className="text-sm text-gray-600">DID: {did.id}</p>
                    </div>
                    <div className="space-y-2">
                      <Button
                        onClick={() => handleVerifyAttribute("age")}
                        disabled={loading}
                      >
                        Verify Age
                      </Button>
                      <Button className="w-full" variant="outline">
                        Verify Residency
                      </Button>
                      <Button className="w-full" variant="outline">
                        Verify Income
                      </Button>
                      <Button className="w-full">Verify All Attributes</Button>
                    </div>
                  </>
                ) : (
                  <div className="text-center py-6">
                    <p className="text-gray-500">
                      Create a DID first to verify attributes
                    </p>
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        </div>
      </main>
    </div>
  );
}
export default IdentityDashboard;



# File: src\web\components\Modal.tsx

import { Dialog, Transition } from "@headlessui/react";
import { Fragment } from "react";

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
}

export const Modal = ({ isOpen, onClose, title, children }: ModalProps) => {
  return (
    <Transition appear show={isOpen} as={Fragment}>
      <Dialog as="div" className="relative z-10" onClose={onClose}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black bg-opacity-25" />
        </Transition.Child>

        <div className="fixed inset-0 overflow-y-auto">
          <div className="flex min-h-full items-center justify-center p-4 text-center">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 scale-95"
              enterTo="opacity-100 scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 scale-100"
              leaveTo="opacity-0 scale-95"
            >
              <Dialog.Panel className="w-full max-w-md transform overflow-hidden rounded-2xl bg-white p-6 text-left align-middle shadow-xl transition-all">
                <Dialog.Title
                  as="h3"
                  className="text-lg font-medium leading-6 text-gray-900"
                >
                  {title}
                </Dialog.Title>
                {children}
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition>
  );
};



# File: src\web\components\ProofGenerationModal.tsx

import React, { useState } from "react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "../components/Alert";
import { Shield, AlertCircle } from "lucide-react";

interface ProofGenerationModalProps {
  isOpen: boolean;
  onClose: () => void;
  attribute: string;
  onGenerateProof: (attribute: string, threshold: string) => void;
  loading: boolean;
}

const ProofGenerationModal = ({
  isOpen,
  onClose,
  attribute,
  onGenerateProof,
  loading,
}: ProofGenerationModalProps) => {
  const [threshold, setThreshold] = useState("");

  const handleGenerateProof = () => {
    onGenerateProof(attribute, threshold);
  };

  return (
    <AlertDialog open={isOpen} onOpenChange={onClose}>
      <AlertDialogContent className="sm:max-w-[425px]">
        <AlertDialogHeader>
          <AlertDialogTitle className="flex items-center">
            <Shield className="w-5 h-5 mr-2 text-indigo-600" />
            Generate Proof for {attribute}
          </AlertDialogTitle>
          <AlertDialogDescription>
            Generate a zero-knowledge proof to verify this attribute without
            revealing its actual value.
          </AlertDialogDescription>
        </AlertDialogHeader>

        <div className="py-4">
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Verification Threshold
          </label>
          <input
            type="number"
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            value={threshold}
            onChange={(e) => setThreshold(e.target.value)}
            placeholder={`Enter ${attribute.toLowerCase()} threshold`}
          />
          <p className="mt-2 text-sm text-gray-500">
            {attribute === "Age" && "Prove your age is above this value"}
            {attribute === "Income" && "Prove your income is above this value"}
            {attribute === "Residency" &&
              "Prove your residency matches this value"}
          </p>
        </div>

        {loading && (
          <div className="mb-4 p-4 bg-indigo-50 rounded-lg flex items-center">
            <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-indigo-600 mr-2"></div>
            <span className="text-sm text-indigo-700">Generating proof...</span>
          </div>
        )}

        <AlertDialogFooter>
          <AlertDialogCancel disabled={loading}>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={handleGenerateProof}
            disabled={!threshold || loading}
            className="bg-indigo-600 hover:bg-indigo-700"
          >
            Generate Proof
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
};

export default ProofGenerationModal;



# File: src\web\components\VerificationStatus.tsx

import React from "react";
import { CheckCircle2, XCircle, Clock, AlertCircle } from "lucide-react";
import { Card, CardContent, CardHeader, CardTitle } from "../components/Card";
import { Alert, AlertDescription } from "../components/Alert";

interface VerificationResult {
  status: "verified" | "failed" | "pending";
  attribute: string;
  timestamp?: string;
}

interface VerificationStatusProps {
  verificationResults?: VerificationResult[];
  isLoading: boolean;
}

const VerificationStatus = ({
  verificationResults,
  isLoading,
}: VerificationStatusProps) => {
  const getStatusIcon = (status: VerificationResult["status"]) => {
    switch (status) {
      case "verified":
        return <CheckCircle2 className="w-5 h-5 text-green-500" />;
      case "failed":
        return <XCircle className="w-5 h-5 text-red-500" />;
      case "pending":
        return <Clock className="w-5 h-5 text-yellow-500" />;
      default:
        return <AlertCircle className="w-5 h-5 text-gray-500" />;
    }
  };

  const getStatusColor = (status: VerificationResult["status"]) => {
    switch (status) {
      case "verified":
        return "bg-green-50 border-green-200";
      case "failed":
        return "bg-red-50 border-red-200";
      case "pending":
        return "bg-yellow-50 border-yellow-200";
      default:
        return "bg-gray-50 border-gray-200";
    }
  };

  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Verification in Progress</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex items-center justify-center py-6">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
          </div>
          <Alert>
            <AlertDescription>
              Generating and verifying zero-knowledge proofs...
            </AlertDescription>
          </Alert>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Verification Status</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {verificationResults?.map((result, index) => (
            <div
              key={index}
              className={`p-4 rounded-lg border ${getStatusColor(result.status)} flex items-center justify-between`}
            >
              <div className="flex items-center">
                {getStatusIcon(result.status)}
                <span className="ml-2 font-medium">{result.attribute}</span>
              </div>
              <div className="text-sm text-gray-600">
                {result.timestamp
                  ? new Date(result.timestamp).toLocaleString()
                  : ""}
              </div>
            </div>
          ))}

          {(!verificationResults || verificationResults.length === 0) && (
            <div className="text-center py-4 text-gray-500">
              No verification results available
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
};

export default VerificationStatus;



# File: src\web\contexts\Web3Context.tsx

import React, { createContext, useContext, useState, useEffect } from "react";
import { Web3Service } from "../../utils/web3";
import { ethers } from "ethers";
import IdentityVerifierABI from "../../../artifacts/src/contracts/IdentityVerifier.sol/IdentityVerifier.json";
import { Web3ContextState, EthereumProvider } from "../../types/ethereum";
import { config, validateConfig } from "../../config";

const Web3Context = createContext<Web3ContextState | null>(null);

export const useWeb3 = () => {
  const context = useContext(Web3Context);
  if (!context) {
    throw new Error("useWeb3 must be used within a Web3Provider");
  }
  return context;
};

export const Web3Provider = ({ children }: { children: React.ReactNode }) => {
  const [web3Service, setWeb3Service] = useState<Web3Service | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [account, setAccount] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);

  const getProvider = (): EthereumProvider | undefined => {
    return window.ethereum;
  };

  useEffect(() => {
    const initializeWeb3 = async () => {
      try {
        // Validate configuration
        validateConfig();

        console.log("Contract Address:", config.CONTRACT_ADDRESS); // Debug log

        const service = new Web3Service(config.PROVIDER_URL);
        await service.initialize(config.CONTRACT_ADDRESS, IdentityVerifierABI);
        setWeb3Service(service);

        const provider = getProvider();
        if (provider?.selectedAddress) {
          setAccount(provider.selectedAddress);
          setIsConnected(true);
        }
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : "Failed to initialize Web3";
        console.error("Web3 initialization error:", errorMessage);
        setError(errorMessage);
      }
    };

    initializeWeb3();
  }, []);
  // Handle account changes
  useEffect(() => {
    const provider = getProvider();
    if (provider) {
      const handleAccountsChanged = (accounts: string[]) => {
        if (accounts.length > 0) {
          setAccount(accounts[0]);
          setIsConnected(true);
        } else {
          setAccount(null);
          setIsConnected(false);
        }
      };

      const handleChainChanged = (_chainId: string) => {
        window.location.reload();
      };

      provider.on("accountsChanged", handleAccountsChanged);
      provider.on("chainChanged", handleChainChanged);

      return () => {
        provider.removeListener("accountsChanged", handleAccountsChanged);
        provider.removeListener("chainChanged", handleChainChanged);
      };
    }
  }, []);

  const connect = async () => {
    try {
      const provider = getProvider();
      if (!provider) {
        throw new Error("MetaMask not installed");
      }

      const accounts = await provider.request({
        method: "eth_requestAccounts",
      });

      if (accounts.length > 0) {
        setAccount(accounts[0]);
        setIsConnected(true);
      }
    } catch (error) {
      console.error("Failed to connect wallet:", error);
      throw error;
    }
  };

  const disconnect = () => {
    setAccount(null);
    setIsConnected(false);
  };

  const verifyProof = async (proof: any, publicSignals: any) => {
    if (!web3Service) throw new Error("Web3 service not initialized");
    return await web3Service.verifyProof(proof, publicSignals);
  };

  const checkVerificationStatus = async (address: string) => {
    if (!web3Service) throw new Error("Web3 service not initialized");
    return await web3Service.checkVerificationStatus(address);
  };

  const value: Web3ContextState = {
    web3Service,
    isConnected,
    account,
    error,
    connect,
    disconnect,
    verifyProof,
    checkVerificationStatus,
  };

  return <Web3Context.Provider value={value}>{children}</Web3Context.Provider>;
};



# File: src\web\services\DIDService.ts

import { DID } from "../../types/did";
import { DIDManager } from "../../did/manager";
import { VerificationService } from "../../services/verificationService";
import { generateProof } from "../../circuits/proofGenerator";

export class DIDService {
  private didManager: DIDManager;
  private verificationService: VerificationService;

  constructor(providerUrl: string, contractAddress: string, contractABI: any) {
    this.didManager = new DIDManager();
    this.verificationService = new VerificationService(
      providerUrl,
      contractAddress,
      contractABI
    );
  }

  async createDID(credentials: DID["credentials"]): Promise<DID> {
    return this.didManager.createDID(credentials);
  }

  async getDID(id: string): Promise<DID | null> {
    return this.didManager.getDID(id);
  }

  async generateProof(didId: string, attribute: string, condition: any) {
    const did = await this.didManager.getDID(didId);
    if (!did) throw new Error("DID not found");

    return await generateProof({
      [attribute]: did.credentials[attribute],
      ageThreshold: condition.threshold,
      secret: did.secret,
    });
  }
}



# File: src\web\styles\globals.css

@tailwind base;
@tailwind components;
@tailwind utilities;



# File: src\web\utils\errorHandling.ts

export class Web3Error extends Error {
  constructor(
    message: string,
    public code?: string
  ) {
    super(message);
    this.name = "Web3Error";
  }
}

export class DIDError extends Error {
  constructor(
    message: string,
    public code?: string
  ) {
    super(message);
    this.name = "DIDError";
  }
}

export function handleError(error: unknown): string {
  if (error instanceof Web3Error) {
    return `Web3 Error: ${error.message}`;
  }
  if (error instanceof DIDError) {
    return `DID Error: ${error.message}`;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return "An unknown error occurred";
}



# File: test\identity.test.ts

import { expect } from "chai";
import { DIDManager } from "../src/did/manager";
import { ProofGenerator } from "../src/circuits/proofGenerator";

describe("Privacy-Preserving Identity Verification", () => {
  let didManager: DIDManager;
  let proofGenerator: ProofGenerator;

  before(async () => {
    didManager = new DIDManager();
    proofGenerator = new ProofGenerator();
  });

  describe("DID Creation and Management", () => {
    it("should create a new DID with credentials", async () => {
      const credentials = {
        age: 25,
        income: 50000,
        residency: "NY",
      };
      const did = await didManager.createDID(credentials);
      expect(did).to.have.property("id");
      expect(did).to.have.property("credentials");
    });
  });

  describe("ZK-SNARK Proof Generation", () => {
    it("should generate proof for age verification", async () => {
      const ageToProve = 25;
      const threshold = 18;
      const proof = await proofGenerator.generateMultiAttributeProof(
        { age: ageToProve, income: 0, residency: "" },
        { ageThreshold: threshold }
      );
      expect(proof).to.have.property("proof");
      expect(proof).to.have.property("publicSignals");
    });
  });
});

